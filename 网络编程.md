表示Ipv4地址的结构体

```c++
struct sockaddr_in
{
	sa_family_t sin_family; //地址族
	uint16_t sin_port;//16位端口号
	struct in_addr sin_addr;//32位IP地址
	char sin_zero[8];//不使用
}
```

```c++
struct in_addr
{
	in_addr_t s_addr;//32位ipv4地址
}
```

```c++
struct sockaddr
{
	sa_family_t sin_family;//地址族
	char sa_data[14];//地址信息，包含ip地址和port端口号，其余位补0
    //通过sockaddr_in强制转换为socketaddr，可以生产符号的bind参数
}
```



### 字节序转换

```c++
unsigned short htons(unsigned short);
unsigned short ntohs(unsigned short);
unsigned long htonl(unsigned long);
unsigned long tonhl(unsigned long);
```

### 字符串转换为网络字节序

```c++
#include<arpa/inet.h>
in_addr_t inet_addr(const char* string);//成功时返回32位大端整数型值，失败时返回INADDR_NONE

例如：
    char *addr1="1.2.3.4";
	unsigned long conv = inet_addr(addr1);//结果为0x4030201
	char *addr2="1.2.3.256";
	conv = inet_addr(addr2);//结果为INADDR_NONE
	
```

inet_aton与inet_addr函数功能相同，也是将字符串转换为整形地址。但该函数使用了in_addr结构体，使用更高频

```c++
#include<arpa/inet.h>
int inet_aton(const char* string, struct in_addr *addr);
//成功时返回1，失败时返回0
```

与inet_aton相反的函数是inet_ntoa，可以把网络字节序整数型IP地址转换为熟悉的字符串形式

```c++
#include<arpa/inet.h>
char* inet_ntoa(struct in_addr adr);//成功返回字符串数组，失败返回-1
/*但要小心，返回值为 char 指针，返回字符串地址意味着字符串已经保存在内存空间，但是该函数未向程序员要求分配内存，而是在内部申请了内存保存了字符串。也就是说调用了该函数候要立即把信息复制到其他内存空间。因此，若再次调用 inet_ntoa 函数，则有可能覆盖之前保存的字符串信息。总之，再次调用 inet_ntoa 函数前返回的字符串地址是有效的。若需要长期保存，则应该将字符串复制到其他内存空间。*/
```



## 基于TCP的服务器/客户端

### TCP 服务端的默认函数的调用程序

<img src="C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220629192103120.png" alt="image-20220629192103120" style="zoom:50%;" />

### 等待连接请求状态

已经调用了bind函数给套接字分配地址，接下来就是要通过调用listen函数进入等待连接请求状态。只有调用了listen函数，客户端才能进入可发出请求状态。也就是说客户端可以调用connect函数

```c++
#include<sys/socket.h>
int listen(int sockfd, int backlog);//成功时返回0，失败时返回1
//sockfd: 进入等待连接请求状态的套接字文件描述符
//backlog:连接请求等待队列的长度
```

### 受理客户端连接请求

调用listen函数后，若有新的连接请求，按序处理。受理请求意味着可接收数据的状态。进入这种状态使用的是套接字，但并不是服务器端的套接字，而是另一个新的套接字，由函数自动创建。

```c++
#include<sys/socket.h>

int accept(int sock, struct sockaddr* addr, socket_t* addrlen);//成功时返回套接字描述符，失败时返回-1
//sock服务器套接字描述符
//addr 保存发起连接的客户端地址信息的变量地址值
//addrlen addr的长度
```

accept函数受理连接请求队列中待处理的客户端连接请求。函数调用成功时，函数内部将产生用于数据IO的套接字，并返回字描述符。**注意：套接字时自动创建的，并自动发起与连接请求的客户端建立连接。**

### 回顾Hello World服务端

代码思路：

1. 服务端实现过程中首先要创建套接字，但该套接字还不是真正的套接字
2. 为了完成套接字地址的分配，需要初始化结构体sockaddr_in并调用bind分配IP地址和端口号
3. 调用listen进入等待连接请求状态。设置队列的长度，此时的套接字才是服务端套接字。
4. 调用accept函数从队头去一个连接请求与客户端建立连接，并返回套接字描述符。若accept的队列为空，则不会返回，直到有新的客户端请求。
5. 调用write函数向客户端传送数据，调用close关闭连接

### UDP 服务端的默认函数的调用程序

<img src="C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220629201553436.png" alt="image-20220629201553436" style="zoom:50%;" />